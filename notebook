#!/bin/bash

# notebook - A script to make notes inside terminal
# Licensed under the MIT License
# Copyright (c) 2020 Rekechynsky Dmytro aka DMENT

# NOTE: notebook saves notes on the principle
# "one note - one line", so consider the terms
# "note" and "line" the same.



##### Initialization


# Notes are saved in the file ~/.local_notes
# Backup is located in the file ~/.local_notes_backup
# ~/.local_notes_temp is temporary file, which is
# used for performing operations of deleting lines.

filename=~/.local_notes;
filename_temp=~/.local_notes_temp;
filename_backup=~/.local_notes_backup;

# In order to avoid performing operations at non-existent
# file it's good to create the file.

file_exists=$( ls -A ~/ | grep '.local_notes' );

if [[ -z $file_exists ]];
then
    touch $filename;
fi

# If temporary file exists, remove it.
# Even it is deleted every time after performing some
# operations, it helps to avoid corruptions.

file_temp_exists=$( ls -A ~/ | grep '.local_notes_temp' );

if [[ -n $file_temp_exists ]];
then
    rm $filename_temp;
fi

# This variable is needed only for backup operations.

file_backup_exists=$( ls -A ~/ | grep '.local_notes_backup' );



##### Colors


# notebook has feature to paint notes with
# different colors. This feature is provided
# easily thanks to regular expressions (REGEXP).

# It's not "white color" REGEXP, but "clear
# all formats were set before"

white="\e[0m";

bold="\e[1m";
red="\e[31m";
green="\e[32m";
yellow="\e[33m";
blue="\e[34m";
magenta="\e[35m";
cyan="\e[36m";



##### Variables


# This variable holds text of note, which
# is going to be added.

note=;

# This variable is used for checking for
# odd arguments.

odd_par=;

# For correct number checking.

to_check=;

# Number of note to remove.

to_remove=;

# If you want to remove couple of lines at once,
# this variable holds last number of note to remove.

remove_till=;

# Number of note to edit.

to_edit=;

# Holds color value. The default is white.

color=$white;

# The count of all the notes.

line_count=$( wc -l $filename | awk '{ print $1 }' );

# Detected terminal

terminal=;



##### Functions


# write_notes() adds a note to file in the format:
# LINE_NUMBER. REGEXP_SET_COLOR NOTE REGEXP_CLEAR_FORMAT
# But you can't add empty note.

write_notes()
{
    if [[ -n $note ]];
    then
        number=$( printf "$line_count + 1\n" | bc );
        printf "$number. $color$note$white\n" >> $filename;
    else
            printf "You should add non-empty note\n";
            exit 1;
    fi
}

# choose_color() converts the verbal expression of
# color into REGEXP.
# If you set color, which is not in the list, an error
# message appears.

choose_color()
{
    case $color in

        'white')
            color=$bold;
        ;;
        'red')
            color=$red;
        ;;
        'green')
            color=$green;
        ;;
        'yellow')
            color=$yellow;
        ;;
        'blue')
            color=$blue;
        ;;
        'magenta')
            color=$magenta;
        ;;
        'cyan')
            color=$cyan;
        ;;
        *)
            printf "Possible colors: white, red, green, yellow, blue, magenta, cyan\n";
            exit 1;
        ;;
esac
}

# show_notes() shows all the notes, saved to ~/.local_notes
# If ~/.local_notes is empty, the appropriate message appears.

show_notes()
{
    if [[ $line_count == "0" ]];
    then
        printf "There are no notes.\n"
    else
        cat $filename;
    fi
}

# clear_notes() clears the file ~/.local_notes
# by rewriting text into empty string.

clear_notes()
{
    printf '' > $filename;
}


# correct_number_checking() is the helping
# function for remove_line()
# It checks the arguments for:
# - being the integer, actually;
# - being positive number;
# - being the existent note number (not greater, than
#   count of lines in the file)

correct_number_checking()
{
    number_mask='^[0-9]+$';
    if ! [[ $to_check =~ $number_mask ]];
    then
        printf "Is \'$to_check\' an integer?\n";
        exit 1;
    elif [ $to_check -lt 1 ];
    then
        printf "The line number must be greater then zero.\n";
        exit 1;
    elif [ $to_check -gt $line_count ];
    then
        printf "This line doesn't exist.\n";
        exit 1;
    fi
}

# remove_line() removes the line (or lines) from the file in
# a such way:
# 1) Check $to_remove to be correct argument
# 2) Create temporary file
# 3) Coprying the lines from original to temporary file
#    through iteration (from the first to the line before line
#    that must be removed).
# 4) Continue copying lines from the new point.
#    The new point is:
#    - line after $remove_till
#    - or, if $remove_till is empty, line after $to_remove
# 5) Delete original file, rename temporary file as the original.

remove_line()
{
    to_check=$to_remove;
    correct_number_checking;

    touch $filename_temp;

    i=1;

    while [ $i -lt $to_remove ];
    do
        line=$( cat $filename | head -$i | tail -n1 | cut -d'.' -f2- );
        printf "$i.$line\n" >> $filename_temp;
        i=$[ $i + 1 ];
    done

    if [[ -n $remove_till ]];
    then
        to_check=$remove_till;
        correct_number_checking;
        if [ $remove_till -lt $to_remove ];
        then
            printf "The first argument must be smaller than the second argument.\n";
            exit 1;
        fi
            i=$remove_till;
    fi

    while [ $i -ne $line_count ];
    do
        if [[ -n $remove_till ]];
        then
            index=$[ $i - $remove_till + $to_remove ];
        else
            index=$i;
        fi
        i=$[ $i + 1 ];
        line=$( cat $filename | head -$i | tail -n1 | cut -d'.' -f2- );
        printf "$index.$line\n" >> $filename_temp;
    done

    rm $filename;
    mv $filename_temp $filename;
}

# edit() edits chosen note

edit()
{
    to_check=$to_edit;
    correct_number_checking;

    if [[ -z $note ]];
    then
        printf "The note must be non-empty.\n";
        exit 1;
    fi

    touch $filename_temp;

    i=1;


    while [ $i -lt $to_edit ];
    do
        line=$( cat $filename | head -$i | tail -n1 | cut -d'.' -f2- );
        printf "$i.$line\n" >> $filename_temp;
        i=$[ $i + 1 ];
    done

    color=$( cat $filename | head -$to_edit | tail -n1 | cut -d'.' -f2 | cut -d'm' -f1 );
    m='m';
    edited_note="$to_edit.$color$m$note$white\n";

    printf "$edited_note" >> $filename_temp;

    while [ $i -ne $line_count ];
    do
        i=$[ $i + 1 ];
        line=$( cat $filename | head -$i | tail -n1 | cut -d'.' -f2- );
        printf "$i.$line\n" >> $filename_temp;
    done

    rm $filename;
    mv $filename_temp $filename;
}

# check_options_overflow() ensures that no odd arguments
# are entered.

check_options_overflow()
{
    if [[ -n $odd_par ]];
    then
        printf "Too much arguments!\n";
        exit 1;
    fi
}

# make_backup() creates a copy of original file and
# locates it in ~/.local_notes_backup.
# If ~/.local_notes_backup already exists, the prompt
# requests a user to confirm rewriting existing backup.

make_backup()
{
    if [[ -n $file_backup_exists ]];
    then
        printf "Backup already exists.\n";
        read -p "Do you want to rewrite the backup? [Y/n] " -r;
        if [[ $REPLY =~ ^[Yy]$ ]]
        then
            cp $filename $filename_backup;
            printf "Success.\n"
        fi
    else
        cp $filename $filename_backup;
    fi
}

# restore_notes() rewrites original file with copy
# of backup file.
# But the function does it only in the case of existing
# backup file.

restore_notes()
{
    if [[ -z $file_backup_exists ]];
    then
        printf "No backup file.\n";
    else
        read -p "Do you want to rewrite the notes from backup? [Y/n] " -r;
        if [[ $REPLY =~ ^[Yy]$ ]]
        then
            cp $filename_backup $filename;
            printf "Success.\n"
        fi
    fi
}

# remove_files() is the helping function for
# uninstall() function.
# remove_files() removes the original and backup files.

remove_files()
{
    if [[ -n $file_exists ]];
    then
        rm $filename;
    fi

    if [[ -n $file_backup_exists ]];
    then
        rm $filename_backup;
    fi
}

# three_dots() is the helping function for
# uninstall() function.
# Just an animation for "thinking" effect.

three_dots()
{
    for (( i=0; i < 3; i++ ));
    do
        sleep 1;
        printf ".";
    done;
    sleep 1;
    printf "\n"
}

# print_ok() is the helping function for
# uninstall() function.
# Prints out "OK" status systemd-style
# string.

print_ok()
{
    sleep 0.1;
    o="OK";
    printf "$bold[  $green$o$white$bold  ] ";
}

# print_failed() is the helping function for
# uninstall() function
# Prints out "FAILED" status systemd-style
# string.

print_failed()
{
    sleep 0.1;
    f="FAILED";
    printf "$bold[$red$f$white$bold] ";
}

# uninstall() deletes all the files.
# It helps to prepare before the uninstallation of
# notebook package.
#
# NOTE: in order to have fun, but not loose the notes,
# copy ~/.local_notes and ~/.local_notes_backup into
# some other place.

uninstall()
{
    read -p "Do you want to delete all the files? [Y/n] " -r;
    if [[ $REPLY =~ ^[Yy]$ ]];
    then
        printf "Hm";
        three_dots;
        read -p "Are you sure? [Y/n] " -r;
        if [[ $REPLY =~ ^[Yy]$ ]];
        then
            printf "Well";
            three_dots;
            read -p "Are you completely sure? [Y/n] " -r;
            if [[ $REPLY =~ ^[Yy]$ ]];
            then
                printf "Preparing to uninstall";
                three_dots;
                sleep 1.5;
                clear;
                print_ok;
                printf "Unexpectedly loaded daemon systemd.\n";
                sleep 0.1;
                printf "\t Lennart Poettering, WTF?\n";
                print_ok;
                printf "Sent 'WTF' to Lennart Poettering.\n";
                print_ok;
                printf "Started pretending doing something useful.\n";
                sleep 0.1;
                printf "\t Plugging microwave to USB4...\n";
                print_failed;
                printf "Failed to plug microwave.\n";
                print_ok;
                printf "Sent user's nudes to a random girl.\n";
                sleep 1;
                print_ok;
                printf "Loaded Minecraft with shaders in order to heat the room.\n";
                remove_files;
                print_ok;
                printf "Removed necessary files (at this point).\n";
                print_ok;
                printf "Made Lenin and Stalin alive.\n";
                print_ok;
                printf "Recreated USSR.\n";
                print_ok;
                printf "Changed file permissions to accessible for everyone except capitalists.\n";
                print_ok;
                printf "Checked e-mail for the viruses.\n";
                print_ok;
                printf "Invented the vaccine against AIDS.\n";
                print_ok;
                printf "Installed Backbone.js framework.\n";
                sleep 0.1;
                printf "\t Trying to create good project using Backbone.js...\n";
                print_failed;
                printf "Failed to create good project.\n";
                print_ok;
                printf "Uninstalled Backbone.js framework.\n";
                print_ok;
                printf "Congratulated user's grandmother on 'Still alive today.'\n";
                print_ok;
                printf "Promised user's mother to visit her again.\n";
                print_ok;
                printf "Stopped to pretend doing useful actions.\n";
                print_ok;
                printf "Stopped to scare user with systemd-style messages.\n";
                sleep 2;
            fi
        fi
    else
        phrase1="The files have been corrupted. MW-HA-HA!";
        phrase2="Backup file won't help you.";
        printf "1. $green$bold$phrase1$white\n" > $filename;
        printf "1. $green$bold$phrase2$white\n" > $filename_backup;
        printf "OK\n";
    fi
}

# Autodetection of the terminal emulator.
# NOTE: it's difficult to provide initial command loading
# for terminal emulators, such as:
# Guake.

choose_terminal()
{
    terms=(lxterminal gnome-terminal xterm terminator rxvt Eterm termit xfce4-terminal tilda);
    for t in ${terms[*]}
    do
        if [ $(command -v $t) ]
        then
            terminal=$t
            break
        fi
    done
}

# schedule() schedules notebook loading, provided by at utility.
# Works in this way:
# - chooses one terminal of available to print out notes contents;
# - creates script to load terminal with initial commands.
# NOTE: at uses /bin/sh to load script.
# - prompt to read time to schedule;
# - schedule loading using at.

schedule()
{
    if [[ -z $terminal ]];
    then
        choose_terminal;
    fi

    launcher=;

    case $terminal in

        'gnome-terminal')
            launcher='gnome-terminal -- bash -c "notebook; sleep 1000000"';
            ;;
        'lxterminal')
            launcher='lxterminal --command "notebook; sleep 1000000"';
            ;;
        'xterm')
            launcher='xterm -e "notebook; sleep 1000000"';
            ;;
        'terminator')
            launcher='terminator -e "notebook; sleep 10000"';
            ;;
        'rxvt')
            launcher='rxvt -e bash -c "notebook; sleep 1000000"';
            ;;
        'Eterm')
            launcher='Eterm -e bash -c "notebook; sleep 1000000"';
            ;;
        'termit')
            launcher='termit -e bash -c "notebook; sleep 1000000"';
            ;;
        'xfce4-terminal')
            launcher='xfce4-terminal -e \"bash -c \\\"notebook; sleep 1000000\\\"\"';
            ;;
        'tilda')
            launcher='tilda -c \"bash -c \\\"notebook; sleep 1000000\\\"\"';
            ;;
        '')
            printf "No terminal is detected.\n"
            exit 1;
            ;;
        *)
            printf "For $terminal scheduling feature isn't provided yet.\n";
            exit 1;
            ;;

    esac

    sch_number=$( ls ~ | grep 'scheduled_commands' | wc -l );
    sch_name="scheduled_commands$sch_number.sh";

    while [[ -n $( ls ~ | grep $sch_name ) ]];
    do
        sch_number=$[ $sch_number + 1 ];
        sch_name="scheduled_commands$sch_number.sh";
    done

    touch ~/$sch_name;
    printf "#!/bin/sh
export DISPLAY=$DISPLAY;
$launcher;
rm ~/$sch_name\n" > ~/$sch_name;
    chmod +x ~/$sch_name;

    printf "Print time to schedule using$green$bold at$white utility format\n> ";
    read;
    at $REPLY -f ~/$sch_name;
}

# usage() is the --help section.

usage()
{
printf 'Usage: notebook [OPTION] [VALUE]
Take notes inside the terminal.\n
    -a, --add\t\tAdd note VALUE.
    -p, --paint\t\tSet color VALUE.
               \t\tUse only after -a, for instance:\n
    $ notebook -a "foo" -p "green"\n
    -e, --edit\t\tReplace the note number VALUE with another.
              \t\tFor example:\n
    $ notebook -e 3 "New note"\n
    -c, --clear\t\tClear all the notes.
    -r, --remove\tRemove the line number VALUE.
                \tAlso you can set the interval:\n
    $ notebook -r VALUE1 VALUE2\n
    -b, --backup\tMake a backup.
    -rs, --restore\tRestore notes from backup.
    -sch, --schedule\tSchedule loading notebook for later,
                    \tusing at utility format.
                    \tVALUE is your prefered terminal emulator.
    --uninstall\t\tDelete all files before the uninstall.
               \t\tBe careful.
    -h, --help\t\tShow the help.\n
With no parameters, notebook shows saved notes.\n';
}


##### Main


# I think, Main section is understandable and
# doesn't need any explainations.

case $1 in

    '-a' | '--add')
        shift;
        note=$1;
        if [[ $2 == '-p' || $2 == '--paint' ]];
        then
            shift;
            shift;
            color=$1;
            choose_color;
        fi
        odd_par=$2;
        check_options_overflow;
        write_notes;
        ;;
    '-r' | '--remove')
        shift;
        to_remove=$1;
        shift;
        remove_till=$1;
        odd_par=$2;
        check_options_overflow;
        remove_line;
        ;;
    '-e' | '--edit')
        shift;
        to_edit=$1;
        shift;
        note=$1;
        odd_par=$2;
        check_options_overflow;
        edit;
        ;;
    '-b' | '--backup')
        odd_par=$2;
        check_options_overflow;
        make_backup;
        ;;
    '-rs' | '--restore')
        odd_par=$2;
        check_options_overflow;
        restore_notes;
        ;;
    '-c' | '--clear')
        odd_par=$2;
        check_options_overflow;
        clear_notes;
        ;;
    '--uninstall')
        odd_par=$2;
        check_options_overflow;
        uninstall;
        ;;
    '-h' | '--help')
        odd_par=$2;
        check_options_overflow;
        usage;
        ;;
    '-sch' | '--schedule')
        shift;
        terminal=$1;
        odd_par=$2;
        check_options_overflow;
        schedule;
        ;;
    '')
        show_notes;
        ;;
    *)
        usage;
        ;;

esac



##### End?
